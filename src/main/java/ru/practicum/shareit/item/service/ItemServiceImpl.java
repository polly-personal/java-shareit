package ru.practicum.shareit.item.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import ru.practicum.shareit.booking.constant.Status;
import ru.practicum.shareit.booking.dto.BookingDtoOutForItem;
import ru.practicum.shareit.booking.mapper.BookingMapper;
import ru.practicum.shareit.booking.model.Booking;
import ru.practicum.shareit.booking.repository.BookingRepository;
import ru.practicum.shareit.item.dto.*;
import ru.practicum.shareit.item.exception.*;
import ru.practicum.shareit.item.mapper.CommentMapper;
import ru.practicum.shareit.item.mapper.ItemMapper;
import ru.practicum.shareit.item.model.Comment;
import ru.practicum.shareit.item.model.Item;
import ru.practicum.shareit.item.repository.CommentRepository;
import ru.practicum.shareit.item.repository.ItemRepository;
import ru.practicum.shareit.request.service.ItemRequestService;
import ru.practicum.shareit.user.dto.UserDto;
import ru.practicum.shareit.user.exception.UserIdNotFound;
import ru.practicum.shareit.user.mapper.UserMapper;
import ru.practicum.shareit.user.service.UserService;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@Transactional(readOnly = true)
@RequiredArgsConstructor
@Service
public class ItemServiceImpl implements ItemService {
    private final UserService userService;
    private final BookingRepository bookingRepository;
    private final ItemRequestService itemRequestService;
    private final ItemRepository itemRepository;
    private final CommentRepository commentRepository;

    @Transactional
    @Override
    public ItemDtoOut create(long userId, ItemDtoIn itemDtoIn) {
        userService.idIsExists(userId);
        itemRequestService.idIsExists(itemDtoIn.getItemRequestId());

        Item item = ItemMapper.toItem(itemDtoIn);

        UserDto ownerDto = userService.getById(userId);
        item.setOwner(UserMapper.toUser(ownerDto));
        Item createdItem = itemRepository.save(item);

        log.info("üü© —Å–æ–∑–¥–∞–Ω–∞ –≤–µ—â—å: " + createdItem);
        return ItemMapper.toItemDtoOut(createdItem);
    }

    @Transactional
    @Override
    public ItemDtoOut updateById(long ownerId, long itemId, ItemDtoIn updatedItemDtoIn) {
        ownerIdIsLinkedToItemId(ownerId, itemId);

        String newName = updatedItemDtoIn.getName();
        String newDescription = updatedItemDtoIn.getDescription();
        Boolean newAvailable = updatedItemDtoIn.getAvailable();

        Item updatableItem = itemRepository.findById(itemId).orElseThrow(() -> new UserIdNotFound("–≤–≤–µ–¥–µ–Ω –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π id –≤–µ—â–∏: " + itemId));

        String updatableName = updatableItem.getName();
        String updatableDescription = updatableItem.getDescription();
        Boolean updatableAvailable = updatableItem.getAvailable();

        if (newName != null) {
            if (!updatableName.equals(newName)) {
                updatableItem.setName(newName);
                log.info("üü™ –æ–±–Ω–æ–≤–ª–µ–Ω–æ –ø–æ–ª–µ \"name\": " + updatableItem);
            }
        }
        if (newDescription != null) {
            if (!updatableDescription.equals(newDescription)) {
                updatableItem.setDescription(newDescription);
                log.info("üü™ –æ–±–Ω–æ–≤–ª–µ–Ω–æ –ø–æ–ª–µ \"description\": " + updatableItem);
            }
        }
        if (newAvailable != null) {
            if (!updatableAvailable.equals(newAvailable)) {
                updatableItem.setAvailable(newAvailable);
                log.info("üü™ –æ–±–Ω–æ–≤–ª–µ–Ω–æ –ø–æ–ª–µ \"available\": " + updatableItem);
            }
        }

        Item updatedItem = itemRepository.save(updatableItem);
        return ItemMapper.toItemDtoOut(updatedItem);
    }

    @Transactional
    @Override
    public String deleteById(long itemId) {
        itemRepository.deleteById(itemId);

        String responseAndLogging;
        responseAndLogging = "‚¨õÔ∏è —É–¥–∞–ª–µ–Ω–∞ –≤–µ—â—å –ø–æ itemId: " + itemId;

        log.info(responseAndLogging);
        return responseAndLogging;
    }

    @Override
    public ItemDtoOut getById(long requestorId, long itemId) {
        Item issuedItem = itemRepository.findById(itemId).orElseThrow(() -> new UserIdNotFound("–≤–≤–µ–¥–µ–Ω –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π id –≤–µ—â–∏: " + itemId));

        ItemDtoOut itemDtoOut = ItemMapper.toItemDtoOut(issuedItem);

        if (requestorId == issuedItem.getOwner().getId()) {
            Booking lastBooking = bookingRepository.findFirstByItemIdAndStartBeforeOrderByEndDesc(itemId,
                    LocalDateTime.now()).orElse(null);
            BookingDtoOutForItem lastBookingDtoOutForItem = null;
            if (lastBooking != null) {
                lastBookingDtoOutForItem = BookingMapper.toBookingDtoForItem(lastBooking);
            }

            Booking nextBooking = bookingRepository.findFirstByItemIdAndStartAfterAndStatusOrderByStartAsc(itemId, LocalDateTime.now(), Status.APPROVED).orElse(null);
            BookingDtoOutForItem nextBookingDtoOutForItem = null;
            if (nextBooking != null) {
                nextBookingDtoOutForItem = BookingMapper.toBookingDtoForItem(nextBooking);
            }

            itemDtoOut.setLastBooking(lastBookingDtoOutForItem);
            itemDtoOut.setNextBooking(nextBookingDtoOutForItem);
        }

        itemDtoOut.setComments(CommentMapper.toCommentsDtoOut(commentRepository.findAllByItemId(itemId)));

        log.info("üü¶ –≤—ã–¥–∞–Ω–∞ –≤–µ—â—å: " + itemDtoOut);
        return itemDtoOut;
    }

    @Override
    public ItemDtoOutForBooking getByIdForBooking(long itemId) {
        Item issuedItem = itemRepository.findById(itemId).orElseThrow(() -> new ItemIdNotFound("–≤–≤–µ–¥–µ–Ω –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π" +
                " id –≤–µ—â–∏: " + itemId)); /* —Ç—Ä–µ–±—É–µ—Ç—Å—è —Å—Ç–∞—Ç—É—Å 404 */
        if (issuedItem.getAvailable() == false) { /* —Ç—Ä–µ–±—É–µ—Ç—Å—è —Å—Ç–∞—Ç—É—Å 400 */
            throw new ItemNotAvailableForBooking("–≤–µ—â—å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ –¥–ª—è –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è");
        }

        log.info("üü¶ –≤—ã–¥–∞–Ω–∞ –≤–µ—â—å (ItemDtoOutForBooking) –¥–ª—è BookingService: " + issuedItem);
        return ItemMapper.toItemDtoOutForBooking(issuedItem);
    }

    @Override
    public List<ItemDtoOut> getAllByOwnerId(long ownerId) {
        List<Item> items = itemRepository.findAllByOwnerId(ownerId);
        if (items.isEmpty()) {
            throw new ItemNoItemsExistsYet("–Ω–∏ –æ–¥–Ω–∞ –≤–µ—â—å –µ—â–µ –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞, –∏—Å–ø—Ä–∞–≤—å—Ç–µ —ç—Ç–æ: ‚ûïüì¶");
        }
        List<Long> itemIds = new ArrayList<>();
        items.stream().map(item -> itemIds.add(item.getId())).collect(Collectors.toList());

        List<BookingDtoOutForItem> lastBookings =
                bookingRepository.findFirstByItemIdInAndStartBeforeOrderByEndDesc(itemIds, LocalDateTime.now())
                        .stream()
                        .map(BookingMapper::toBookingDtoForItem)
                        .collect(Collectors.toList());
        Map<Long, BookingDtoOutForItem> lastBookingToItemId = new HashMap<>();
        for (BookingDtoOutForItem lastBooking : lastBookings) {
            lastBookingToItemId.put(lastBooking.getItemId(), lastBooking);
        }

        List<BookingDtoOutForItem> nextBookings =
                bookingRepository.findFirstByItemIdInAndStartAfterAndStatusOrderByStartAsc(itemIds, LocalDateTime.now(),
                                Status.APPROVED)
                        .stream()
                        .map(BookingMapper::toBookingDtoForItem)
                        .collect(Collectors.toList());
        Map<Long, BookingDtoOutForItem> nextBookingToItemId = new HashMap<>();
        for (BookingDtoOutForItem nextBooking : nextBookings) {
            nextBookingToItemId.put(nextBooking.getItemId(), nextBooking);
        }

        List<ItemDtoOut> itemsDtoOut = ItemMapper.toItemsDtoOut(items)
                .stream().map(itemDtoOut -> {
                    itemDtoOut.setLastBooking(lastBookingToItemId.get(itemDtoOut.getId()));
                    itemDtoOut.setNextBooking(nextBookingToItemId.get(itemDtoOut.getId()));

                    return itemDtoOut;
                }).collect(Collectors.toList());

        log.info("üü¶ –≤—ã–¥–∞–Ω —Å–ø–∏—Å–æ–∫ –≤–µ—â–µ–π: " + itemsDtoOut + ", –¥–ª—è –≤–ª–∞–¥–µ–ª—å—Ü–∞ —Å id: " + ownerId);
        return itemsDtoOut;
    }

    @Override
    public void idIsExists(Long id) {
        if (!itemRepository.existsById(id)) {
            throw new UserIdNotFound("–≤–≤–µ–¥–µ–Ω –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π id –≤–µ—â–∏: " + id);
        }
    }

    @Override
    public List<ItemDtoOut> searchForUserByParameter(String text) {
        List<Item> issuedItems = new ArrayList<>();

        if (text != null && !text.isBlank()) {

            issuedItems = itemRepository.findByNameContainingIgnoreCaseOrDescriptionContainingIgnoreCaseAndAvailableTrue(text, text);
            log.info("üü¶üü¶ –≤—ã–¥–∞–Ω —Å–ø–∏—Å–æ–∫ –≤–µ—â–µ–π: " + issuedItems + ", –ø–æ –ø–æ–∏—Å–∫—É (–ø–∞—Ä–∞–º–µ—Ç—Ä—É): " + text);
        } else {

            log.info("üü¶üü¶ –≤—ã–¥–∞–Ω –ü–£–°–¢–û–ô —Å–ø–∏—Å–æ–∫ –≤–µ—â–µ–π: " + issuedItems + ", –ø–æ –ø–æ–∏—Å–∫—É (–ø–∞—Ä–∞–º–µ—Ç—Ä—É): \"" + text + "\"");
        }

        return ItemMapper.toItemsDtoOut(issuedItems);
    }

    @Transactional
    @Override
    public CommentDtoOut createComment(long commentatorId, long itemId, CommentDtoIn commentDtoIn) {
        Item item = itemRepository.findById(itemId).orElseThrow(() -> new UserIdNotFound("–≤–≤–µ–¥–µ–Ω –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π id –≤–µ—â–∏: " + itemId));

        UserDto formerBooker = userService.getById(commentatorId);

        List<Booking> bookings = bookingRepository.findAllByBookerIdAndItemIdAndEndBeforeAndStatusEquals(commentatorId, itemId, LocalDateTime.now(), Status.APPROVED);

        if (!bookings.isEmpty()) {

            Comment comment = CommentMapper.toComment(commentDtoIn);

            comment.setItem(item);
            comment.setAuthor(UserMapper.toUser(formerBooker));
            comment.setCreated(LocalDateTime.now());

            log.info("üü© —Å–æ–∑–¥–∞–Ω –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π: " + comment);
            return CommentMapper.toCommentDtoOut(commentRepository.save(comment));
        }
        throw new ItemCommentatorIdNotHaveCompletedBooking("–∫–æ–º–º–µ–Ω—Ç–∞—Ç–æ—Ä –Ω–µ –∏–º–µ–µ—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–Ω–æ–π –±—Ä–æ–Ω–∏");
    }

    private void ownerIdIsLinkedToItemId(long ownerId, long itemId) {
        userService.idIsExists(ownerId);

        Item issuedItem = itemRepository.findById(itemId).orElseThrow(() -> new UserIdNotFound("–≤–≤–µ–¥–µ–Ω –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π id –≤–µ—â–∏: " + itemId));
        if (ownerId != issuedItem.getOwner().getId()) {
            throw new ItemOwnerIdIsNotLinkedToItemId("id –≤–µ—â–∏: " + itemId + " –Ω–µ —Å–≤—è–∑–∞–Ω —Å id –≤–ª–∞–¥–µ–ª—å—Ü–∞: " + ownerId);
        }
    }
}
